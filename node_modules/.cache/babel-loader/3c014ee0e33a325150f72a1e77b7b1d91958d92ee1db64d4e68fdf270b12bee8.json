{"ast":null,"code":"/*!\r\n * on-finished\r\n * Copyright(c) 2013 Jonathan Ong\r\n * Copyright(c) 2014 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module exports.\r\n * @public\r\n */\nmodule.exports = onFinished;\nmodule.exports.isFinished = isFinished;\n\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nvar first = require('ee-first');\n\n/**\r\n * Variables.\r\n * @private\r\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function' ? setImmediate : function (fn) {\n  process.nextTick(fn.bind.apply(fn, arguments));\n};\n\n/**\r\n * Invoke callback when the response has finished, useful for\r\n * cleaning up resources afterwards.\r\n *\r\n * @param {object} msg\r\n * @param {function} listener\r\n * @return {object}\r\n * @public\r\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg);\n    return msg;\n  }\n\n  // attach the listener to the message\n  attachListener(msg, listener);\n  return msg;\n}\n\n/**\r\n * Determine if message is already finished.\r\n *\r\n * @param {object} msg\r\n * @return {boolean}\r\n * @public\r\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket;\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || socket && !socket.writable);\n  }\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);\n  }\n\n  // don't know\n  return undefined;\n}\n\n/**\r\n * Attach a finished listener to the message.\r\n *\r\n * @param {object} msg\r\n * @param {function} callback\r\n * @private\r\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg;\n  var eeSocket;\n  var finished = false;\n  function onFinish(error) {\n    eeMsg.cancel();\n    eeSocket.cancel();\n    finished = true;\n    callback(error);\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish);\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket);\n    if (finished) return;\n    if (eeMsg !== eeSocket) return;\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish);\n  }\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket);\n    return;\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket);\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    patchAssignSocket(msg, onSocket);\n  }\n}\n\n/**\r\n * Attach the listener to the message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished;\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg);\n    attachFinishedListener(msg, attached);\n  }\n  attached.queue.push(listener);\n}\n\n/**\r\n * Create listener on message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null;\n    if (!listener.queue) return;\n    var queue = listener.queue;\n    listener.queue = null;\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg);\n    }\n  }\n  listener.queue = [];\n  return listener;\n}\n\n/**\r\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\r\n *\r\n * @param {ServerResponse} res\r\n * @param {function} callback\r\n * @private\r\n */\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket;\n  if (typeof assignSocket !== 'function') return;\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket);\n    callback(socket);\n  };\n}","map":{"version":3,"names":["module","exports","onFinished","isFinished","first","require","defer","setImmediate","fn","process","nextTick","bind","apply","arguments","msg","listener","attachListener","socket","finished","Boolean","writable","complete","upgrade","readable","undefined","attachFinishedListener","callback","eeMsg","eeSocket","onFinish","error","cancel","onSocket","removeListener","on","patchAssignSocket","attached","__onFinished","queue","createListener","push","err","i","length","res","assignSocket","_assignSocket","call"],"sources":["C:/Users/Admin/Downloads/source_code/node_modules/on-finished/index.js"],"sourcesContent":["/*!\r\n * on-finished\r\n * Copyright(c) 2013 Jonathan Ong\r\n * Copyright(c) 2014 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\r\n\r\n'use strict'\r\n\r\n/**\r\n * Module exports.\r\n * @public\r\n */\r\n\r\nmodule.exports = onFinished\r\nmodule.exports.isFinished = isFinished\r\n\r\n/**\r\n * Module dependencies.\r\n * @private\r\n */\r\n\r\nvar first = require('ee-first')\r\n\r\n/**\r\n * Variables.\r\n * @private\r\n */\r\n\r\n/* istanbul ignore next */\r\nvar defer = typeof setImmediate === 'function'\r\n  ? setImmediate\r\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\r\n\r\n/**\r\n * Invoke callback when the response has finished, useful for\r\n * cleaning up resources afterwards.\r\n *\r\n * @param {object} msg\r\n * @param {function} listener\r\n * @return {object}\r\n * @public\r\n */\r\n\r\nfunction onFinished(msg, listener) {\r\n  if (isFinished(msg) !== false) {\r\n    defer(listener, null, msg)\r\n    return msg\r\n  }\r\n\r\n  // attach the listener to the message\r\n  attachListener(msg, listener)\r\n\r\n  return msg\r\n}\r\n\r\n/**\r\n * Determine if message is already finished.\r\n *\r\n * @param {object} msg\r\n * @return {boolean}\r\n * @public\r\n */\r\n\r\nfunction isFinished(msg) {\r\n  var socket = msg.socket\r\n\r\n  if (typeof msg.finished === 'boolean') {\r\n    // OutgoingMessage\r\n    return Boolean(msg.finished || (socket && !socket.writable))\r\n  }\r\n\r\n  if (typeof msg.complete === 'boolean') {\r\n    // IncomingMessage\r\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\r\n  }\r\n\r\n  // don't know\r\n  return undefined\r\n}\r\n\r\n/**\r\n * Attach a finished listener to the message.\r\n *\r\n * @param {object} msg\r\n * @param {function} callback\r\n * @private\r\n */\r\n\r\nfunction attachFinishedListener(msg, callback) {\r\n  var eeMsg\r\n  var eeSocket\r\n  var finished = false\r\n\r\n  function onFinish(error) {\r\n    eeMsg.cancel()\r\n    eeSocket.cancel()\r\n\r\n    finished = true\r\n    callback(error)\r\n  }\r\n\r\n  // finished on first message event\r\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\r\n\r\n  function onSocket(socket) {\r\n    // remove listener\r\n    msg.removeListener('socket', onSocket)\r\n\r\n    if (finished) return\r\n    if (eeMsg !== eeSocket) return\r\n\r\n    // finished on first socket event\r\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\r\n  }\r\n\r\n  if (msg.socket) {\r\n    // socket already assigned\r\n    onSocket(msg.socket)\r\n    return\r\n  }\r\n\r\n  // wait for socket to be assigned\r\n  msg.on('socket', onSocket)\r\n\r\n  if (msg.socket === undefined) {\r\n    // node.js 0.8 patch\r\n    patchAssignSocket(msg, onSocket)\r\n  }\r\n}\r\n\r\n/**\r\n * Attach the listener to the message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\r\n\r\nfunction attachListener(msg, listener) {\r\n  var attached = msg.__onFinished\r\n\r\n  // create a private single listener with queue\r\n  if (!attached || !attached.queue) {\r\n    attached = msg.__onFinished = createListener(msg)\r\n    attachFinishedListener(msg, attached)\r\n  }\r\n\r\n  attached.queue.push(listener)\r\n}\r\n\r\n/**\r\n * Create listener on message.\r\n *\r\n * @param {object} msg\r\n * @return {function}\r\n * @private\r\n */\r\n\r\nfunction createListener(msg) {\r\n  function listener(err) {\r\n    if (msg.__onFinished === listener) msg.__onFinished = null\r\n    if (!listener.queue) return\r\n\r\n    var queue = listener.queue\r\n    listener.queue = null\r\n\r\n    for (var i = 0; i < queue.length; i++) {\r\n      queue[i](err, msg)\r\n    }\r\n  }\r\n\r\n  listener.queue = []\r\n\r\n  return listener\r\n}\r\n\r\n/**\r\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\r\n *\r\n * @param {ServerResponse} res\r\n * @param {function} callback\r\n * @private\r\n */\r\n\r\nfunction patchAssignSocket(res, callback) {\r\n  var assignSocket = res.assignSocket\r\n\r\n  if (typeof assignSocket !== 'function') return\r\n\r\n  // res.on('socket', callback) is broken in 0.8\r\n  res.assignSocket = function _assignSocket(socket) {\r\n    assignSocket.call(this, socket)\r\n    callback(socket)\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}